#!/bin/sh
# This script should live in /engineyard/bin/ and be named monit_mongrel
# Big ups to jvantuyl for iteration 0

# FIXME: Maybe we can use netstat to make sure the port is available - jvantuyl
mdk_mongrel() {
  if [ -e "${PIDFILE}" ]; then
    OLDPID=`cat ${PIDFILE}`
    if [ ! -d /proc/$OLDPID ] ; then
      rm -f $PIDFILE
      OLDPID=""
    elif [ `grep "^Name:" /proc/$OLDPID/status | awk '{print $2}'` != "mongrel_rails" ]; then
      rm -f $PIDFILE
      OLDPID=""
    fi
  fi
  #Pid file didn't exist, ask pgrep for it
  if [ "$OLDPID" = "" ]; then
    OLDPID=`pgrep -f "ruby.*mongrel_rails\ start.*\-p $PORT"`
  fi

  # See if we can find the pid based on what pid is listening to the port
  if  [ "$OLDPID" = "" ]; then
    possible_PID="`netstat -nap | grep "127.0.0.1:$PORT " | grep LISTEN | awk '{print $7}' | sed -e 's#/.*##'`"
    if [ ! -z "$possible_PID" ] ; then
      if [ "`grep "^Name:" /proc/$possible_PID/status | awk '{print $2}'`" = "mongrel_rails" ]; then
        OLDPID="$possible_PID"
      fi
    fi
  fi

  if [ "$OLDPID" != "" ]; then
    #Try stopping it gracefully, kill $OLDPID is the same as cluster::stop
    kill $OLDPID
    # 5 seconds really isn't enough of a wait time, but it's good for situations where shit hit the fan
    sleep 5
    #Does the process still exist?  If it does, client sites are gonna white screen
    if [ -e /proc/$OLDPID ]; then
      #Murder the damn thing.  Kill em, fuckin' kill em.
      kill -9 $OLDPID
      sleep 3
      #Does it still exist!?!  Atleast give some log love alerting us that it failed
      if [ -e /proc/$OLDPID ]; then
        #Alert someone? and exit with an error
        echo "Process $OLDPID won't die!" >> /var/log/engineyard/apps/$APPLICATION/mongrel.$PORT.log 2>&1
        exit 1
      fi
    fi
  fi
  
  #check for the STOP_LOCKFILE and delete it if it is there.
  if [ -e $STOP_LOCKFILE ]; then
    logger -t "monit_mongrel_$PORT" "stop process removing $STOP_LOCKFILE"
    rm $STOP_LOCKFILE
  fi

  [ -e "$PIDFILE" ] && rm -f $PIDFILE
  return 0
}

usage() {
  echo "Usage: $0 application {start, stop} port"
  echo "$0 kongregate start 5000"
  echo "You can also run it w/o parameters from monit"
  echo "and the application/command/port will be inferred by monit env variables"
  echo "These variables are MONIT_SERVICE and MONIT_EVENT"
  echo "$0"
  exit 1
}

##
# script actually starts
##

if [ "`whoami`" != "root" ]; then
  logger -t `basename $0` -s "Must be run as root" 
  exit 1
fi
if [ $# -lt 3 ]; then # running under monit w/o params
  ACTION="`echo "$MONIT_EVENT" | tr \"[:upper:]\" \"[:lower:]\"`"  # translate Start to start and Stop to stop
  APPLICATION="`echo $MONIT_SERVICE | perl -p -e 's/^([^_]+)_(.*)?_(\d+)/$2/'`" # grab the stuff between the services 
  PORT="`echo $MONIT_SERVICE | perl -p -e 's/^([^_]+)_(.*)?_(\d+)/$3/'`" # grab the port out of the last stuff
  echo "Grabbed params from monit $APPLICATION,$ACTION,$PORT" > /var/log/engineyard/mongrel/monit_mongrel.log 2>&1
  # [ -z $ACTION ] || [ -z $APPLICATION ] || [ -z $PORT ] && usage
else
  APPLICATION=$1 ; ACTION=$2 ; PORT=$3
fi

# Now that we have some variables let's set the PIDFILE
PIDFILE="/var/run/mongrel/$APPLICATION/mongrel.$PORT.pid"

#STOP_LOCKFILE used to make sure start waits for any stop to finish (up to 30 seconds)
STOP_LOCKFILE="/tmp/$PORT.mdk_mongrel"

# what it do? 
case $ACTION in
  start*)
  
    logger -t "monit_mongrel_$PORT" "start called"
    
    if [ `grep "^\(user\|group\):" /data/$APPLICATION/current/config/mongrel_cluster.yml | wc -l` != "2" ]; then
      logger -t `basename $0` -s "Mongrel cluster config file does not specify user and/or group to run as - check /data/$APPLICATION/current/config/mongrel_cluster.yml"
      exit 1
    fi
    
    #sleep counter to make sure we don't run start during stop using STOP_LOCKFILE
    SLEEP_COUNT=0
    while [ -e $STOP_LOCKFILE ]; do
      logger -t "monit_mongrel_$PORT" "$STOP_LOCKFILE exists sleeping for .25 and checking again"
      sleep .25 
      let "SLEEP_COUNT+=1"
      if(( "$SLEEP_COUNT" > 120 )); then
        logger -t "monit_mongrel_$PORT" "killing the stop lock file waited 30 seconds"
        if [ -e $STOP_LOCKFILE ]; then
          logger -t "monit_mongrel_$PORT" "start remove stop_lockfile: $STOP_LOCKFILE"
          rm $STOP_LOCKFILE
        fi
      fi
    done 
    
    mdk_mongrel
    USER=`stat -c"%U" /data/$APPLICATION/current`
    INLINEDIR="/data/$APPLICATION/.ruby_inline" ; export INLINEDIR
    HOME="/home/$USER" ; export HOME
    
    logger -t "monit_mongrel_$PORT" "starting mongrel"
    /usr/bin/mongrel_rails cluster::start -C /data/$APPLICATION/current/config/mongrel_cluster.yml --clean --only $PORT
    STATUS=$?
    if [ "$STATUS" = "0" -a -x /engineyard/bin/eyadjust ]; then
      sleep 2
      /engineyard/bin/eyadjust
    fi
    exit $STATUS
    ;;
  stop*)
   logger -t "monit_mongrel_$PORT" "stop called - writing stop lock file $STOP_LOCKFILE"
   touch $STOP_LOCKFILE
  
    mdk_mongrel
    exit $?
    ;;
  *)
    echo 2>&1 'Unrecognized Monit Command: $ACTION'
    usage
    exit 1
    ;;
esac
